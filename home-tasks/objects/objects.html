<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JS:Objects</title>
  <link href="../style.css" rel="stylesheet">
</head>
<body>
  <h1 style="text-align: center">Обьекты</h1>
  <a class="link-back" href="../index.html">На главную</a>
  <p class="task">
    <h3># Задача 1:</h3>
    <div class="btn-wrapper">
      <input class="showAnswerBtn" type="checkbox" id="showAnswerBtn1">
      <label class="showAnswerBtn__label" for="showAnswerBtn1">
        <pre>
var allNumbers = [1, 2, 4, 5, 6, 7, 8],
    someNumbers = [1, 2, 'привет', 4, 5, 'loftschool', 6, 7, 8],
    noNumbers = ['это', 'массив', 'без', 'чисел'];

function filterFn(arr) {
  let res;

  for (let i = 0; i < arr.length; i++) {
    if(typeof arr[i] === 'number') {
      res = 'true';
    } else {
      res = 'false';
      break;
    }
  }

  if(res == 'true') return true;
  else return false;
}

console.log(filterFn(someNumbers));

        </pre>
      </label>
    </div>

    <pre>
      написать модуль, который экспортирует аналоги методов для работы с массивами:
      forEach, filter, map, slice, reduce, splice  пример:

      let array = [1, 2, 3, 4, 5, 6];
      forEach(array, item => console.log(item));
      let greaterThan4 = filter(array, item => item > 4);
      let sqare = map(array, item => item*item);

      Описание того, как работают эти методы, есть на Mozilla Developer Network и в бесплатных видеоуроках LoftBlog/LoftSchool.

      Реализация функции splice является задачей со звездочкой.
      Ее выполнение не обязательно, но желательно.

      Внимание:
      в данном задании запрещено использовать встроенные методы для работы с массивами! Разрешено использовать стандартные
      операторы 'for/for-in/while/if`' (и т.д.) и свойство 'length'
    </pre>
  </p>
  <p class="task">
    <h3># Задача - 2</h3>
    <div class="btn-wrapper">
      <input class="showAnswerBtn" type="checkbox" id="showAnswerBtn2">
      <label class="showAnswerBtn__label" for="showAnswerBtn2">
        <pre>
var allNumbers = [1, 2, 4, 5, 6, 7, 8],
    someNumbers = [1, 2, 'привет', 4, 5, 'loftschool', 6, 7, 8],
    noNumbers = ['это', 'массив', 'без', 'чисел'];

function filterFn(arr) {
  let res;

  for (let i = 0; i < arr.length; i++) {
    if(typeof arr[i] != 'number') {
      res = 'false';
    } else {
      res = 'true';
      break;
    }
  }

  if(res == 'true') return true;
  else return false;
}
    console.log(filterFn(allNumbers));
        </pre>
      </label>
    </div>
    <pre>
      Как известно, в js не существует способа проверить идентичность объектов.
      Написав 'objA === objB' мы получим true только в том случае, если objA и objB указывают на один и тот же объект.

      Задача: написать функцию deepEqual, которая принимает в качестве параметров два аргуманта - два объекта.

      Если обе переменные указывают на один и тот же объект, значит оба объекта идентичны.

      Если оба объекта имеют одинаковые свойства и их значения, значит оба объекта идентичны.

      Посмотрите на примеры того, как должна работать фиункция deepEqual:
      var objA = {
          prop1: 'value1',
          prop2: 'value2',
          prop3: 'value3',
          prop4: {
              subProp1: 'sub value1',
              subProp2: {
                  subSubProp1: 'sub sub value1',
                  subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
              }
          },
          prop5: 1000,
          prop6: new Date(2016, 2, 10)
      };

      var objB = {
          prop5: 1000,
          prop3: 'value3',
          prop1: 'value1',
          prop2: 'value2',
          prop6: new Date('2016/03/10'),
          prop4: {
              subProp2: {
                  subSubProp1: 'sub sub value1',
                  subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
              },
              subProp1: 'sub value1'
          }
      };

      console.log(deepEqual(objA, objB)); //объекты идентичны, вернет true

      Не смотря на то, что свойства в objB перемешаны(последовательность свойста в objB отичается от последовательности свойств в objA), функция всё равно вернет true, так как количество свойств, из имена и значения совпадают у обоих объектов.
      Так же обратите вснимание, что deepEqual должна работать рекурсивно.

      Это значит, что если значением какого-то свойства объекта является массив или объект, то начать сверять и их у обоих объектов.

      Если одним из элементов сверяемого массива, является другой массив или объект, то их тоже надо сверить рекурсивно.

      При сверке объектов - последовательность свойств не важна, но при сверке массивов, вашна последовательность элементов, то есть массивы: `[1,2,3,4]` и `[2,1,3,4]` не равны, так как, хотя и имеют одинаковые значения, отличаются в последовательности этих значений.

      Так же обратите внимание, что даты тоже должны сравниваться корректно, не смотря на отличия в способах создания.

      Запрещено использовать сторонние библиотеки типа jQuery, underscore и прочие.
    </pre>
  </p>
  <script src="home-task-1.js"></script>
  <script src="home-task-2.js"></script>
</body>
</html>
